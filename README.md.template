# Kommando [![Crystal CI](https://github.com/Ragmaanir/kommando/actions/workflows/crystal.yml/badge.svg)](https://github.com/Ragmaanir/kommando/actions/workflows/crystal.yml)

### Version <%= Kommando::VERSION %>

## Installation


Add this to your application's `shard.yml`:

```yaml
dependencies:
  kommando:
    github: ragmaanir/kommando
```

## Features

- positional arguments (like in `crystal init app MyApp`)
- short and long options (like `cli new MyProject --dry -v --permissions=644 --repo=github -l=MIT`)
- validation and type conversion of arguments
- auto-generated documentation
- namespaces/subcommands like `cli create user Toby`

## Rationale

**Why classes for commands and not methods**

Classes can define helper methods that are scoped to the command. And the helper methods have access to all options of the command.

**Why are positional arguments specified as method parameters and options using the `options`-macro?**

Usually commands have many options and just a few arguments. It is easier to spread the options out using the `option`-macro than having them in the method signature on in one big annotation. Specifying a description, validations etc for each options is easier that way too.


## Usage

```crystal
require "kommando"

<%= File.read("./spec/examples/full.cr") %>
```

## Commands

```crystal
<%= File.read("./spec/examples/command.cr") %>
```

## Contributing

1. Fork it (https://github.com/ragmaanir/kommando/fork)
2. Create your feature branch (git checkout -b my-new-feature)
3. Commit your changes (git commit -am 'Add some feature')
4. Push to the branch (git push origin my-new-feature)
5. Create a new Pull Request

## Contributors

- [ragmaanir](https://github.com/ragmaanir) ragmaanir - creator, maintainer
